// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IoArgoprojWorkflowV1alpha1Template Template is a reusable and composable unit of execution in a workflow
//
// swagger:model io.argoproj.workflow.v1alpha1.Template
type IoArgoprojWorkflowV1alpha1Template struct {

	// Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
	ActiveDeadlineSeconds IoK8sApimachineryPkgUtilIntstrIntOrString `json:"activeDeadlineSeconds,omitempty"`

	// Affinity sets the pod's scheduling constraints Overrides the affinity set at the workflow level (if any)
	Affinity *IoK8sAPICoreV1Affinity `json:"affinity,omitempty"`

	// Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the <workflowname>/<nodename> in the key.
	ArchiveLocation *IoArgoprojWorkflowV1alpha1ArtifactLocation `json:"archiveLocation,omitempty"`

	// Arguments hold arguments to the template. DEPRECATED: This field is not used.
	Arguments *IoArgoprojWorkflowV1alpha1Arguments `json:"arguments,omitempty"`

	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty"`

	// Container is the main container image to run in the pod
	Container *IoK8sAPICoreV1Container `json:"container,omitempty"`

	// Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
	Daemon bool `json:"daemon,omitempty"`

	// DAG template subtype which runs a DAG
	Dag *IoArgoprojWorkflowV1alpha1DAGTemplate `json:"dag,omitempty"`

	// Executor holds configurations of the executor container.
	Executor *IoArgoprojWorkflowV1alpha1ExecutorConfig `json:"executor,omitempty"`

	// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
	HostAliases []*IoK8sAPICoreV1HostAlias `json:"hostAliases"`

	// InitContainers is a list of containers which run before the main container.
	InitContainers []*IoArgoprojWorkflowV1alpha1UserContainer `json:"initContainers"`

	// Inputs describe what inputs parameters and artifacts are supplied to this template
	Inputs *IoArgoprojWorkflowV1alpha1Inputs `json:"inputs,omitempty"`

	// Memoize allows templates to use outputs generated from already executed templates
	Memoize *IoArgoprojWorkflowV1alpha1Memoize `json:"memoize,omitempty"`

	// Metdata sets the pods's metadata, i.e. annotations and labels
	Metadata *IoArgoprojWorkflowV1alpha1Metadata `json:"metadata,omitempty"`

	// Metrics are a list of metrics emitted from this template
	Metrics *IoArgoprojWorkflowV1alpha1Metrics `json:"metrics,omitempty"`

	// Name is the name of the template
	// Required: true
	Name *string `json:"name"`

	// NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Outputs describe the parameters and artifacts that this template produces
	Outputs *IoArgoprojWorkflowV1alpha1Outputs `json:"outputs,omitempty"`

	// Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
	Parallelism int64 `json:"parallelism,omitempty"`

	// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
	PodSpecPatch string `json:"podSpecPatch,omitempty"`

	// Priority to apply to workflow pods.
	Priority int32 `json:"priority,omitempty"`

	// PriorityClassName to apply to workflow pods.
	PriorityClassName string `json:"priorityClassName,omitempty"`

	// Resource template subtype which can run k8s resources
	Resource *IoArgoprojWorkflowV1alpha1ResourceTemplate `json:"resource,omitempty"`

	// ResubmitPendingPods is a flag to enable resubmitting pods that remain Pending after initial submission
	ResubmitPendingPods bool `json:"resubmitPendingPods,omitempty"`

	// RetryStrategy describes how to retry a template when it fails
	RetryStrategy *IoArgoprojWorkflowV1alpha1RetryStrategy `json:"retryStrategy,omitempty"`

	// If specified, the pod will be dispatched by specified scheduler. Or it will be dispatched by workflow scope scheduler if specified. If neither specified, the pod will be dispatched by default scheduler.
	SchedulerName string `json:"schedulerName,omitempty"`

	// Script runs a portion of code against an interpreter
	Script *IoArgoprojWorkflowV1alpha1ScriptTemplate `json:"script,omitempty"`

	// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
	SecurityContext *IoK8sAPICoreV1PodSecurityContext `json:"securityContext,omitempty"`

	// ServiceAccountName to apply to workflow pods
	ServiceAccountName string `json:"serviceAccountName,omitempty"`

	// Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes
	Sidecars []*IoArgoprojWorkflowV1alpha1UserContainer `json:"sidecars"`

	// Steps define a series of sequential/parallel workflow steps
	Steps []IoArgoprojWorkflowV1alpha1ParallelSteps `json:"steps"`

	// Suspend template subtype which can suspend a workflow when reaching the step
	Suspend *IoArgoprojWorkflowV1alpha1SuspendTemplate `json:"suspend,omitempty"`

	// Synchronization holds synchronization lock configuration for this template
	Synchronization *IoArgoprojWorkflowV1alpha1Synchronization `json:"synchronization,omitempty"`

	// Template is the name of the template which is used as the base of this template. DEPRECATED: This field is not used.
	Template string `json:"template,omitempty"`

	// TemplateRef is the reference to the template resource which is used as the base of this template. DEPRECATED: This field is not used.
	TemplateRef *IoArgoprojWorkflowV1alpha1TemplateRef `json:"templateRef,omitempty"`

	// Timout allows to set the total node execution timeout duration counting from the node's start time. This duration also includes time in which the node spends in Pending state. This duration may not be applied to Step or DAG templates.
	Timeout string `json:"timeout,omitempty"`

	// Tolerations to apply to workflow pods.
	Tolerations []*IoK8sAPICoreV1Toleration `json:"tolerations"`

	// Volumes is a list of volumes that can be mounted by containers in a template.
	Volumes []*IoK8sAPICoreV1Volume `json:"volumes"`
}

// Validate validates this io argoproj workflow v1alpha1 template
func (m *IoArgoprojWorkflowV1alpha1Template) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveDeadlineSeconds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAffinity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchiveLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArguments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContainer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExecutor(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitContainers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetryStrategy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSidecars(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuspend(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSynchronization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplateRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTolerations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateActiveDeadlineSeconds(formats strfmt.Registry) error {
	if swag.IsZero(m.ActiveDeadlineSeconds) { // not required
		return nil
	}

	if err := m.ActiveDeadlineSeconds.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("activeDeadlineSeconds")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateAffinity(formats strfmt.Registry) error {
	if swag.IsZero(m.Affinity) { // not required
		return nil
	}

	if m.Affinity != nil {
		if err := m.Affinity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("affinity")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateArchiveLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.ArchiveLocation) { // not required
		return nil
	}

	if m.ArchiveLocation != nil {
		if err := m.ArchiveLocation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveLocation")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateArguments(formats strfmt.Registry) error {
	if swag.IsZero(m.Arguments) { // not required
		return nil
	}

	if m.Arguments != nil {
		if err := m.Arguments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("arguments")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateContainer(formats strfmt.Registry) error {
	if swag.IsZero(m.Container) { // not required
		return nil
	}

	if m.Container != nil {
		if err := m.Container.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("container")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateDag(formats strfmt.Registry) error {
	if swag.IsZero(m.Dag) { // not required
		return nil
	}

	if m.Dag != nil {
		if err := m.Dag.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dag")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateExecutor(formats strfmt.Registry) error {
	if swag.IsZero(m.Executor) { // not required
		return nil
	}

	if m.Executor != nil {
		if err := m.Executor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("executor")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateHostAliases(formats strfmt.Registry) error {
	if swag.IsZero(m.HostAliases) { // not required
		return nil
	}

	for i := 0; i < len(m.HostAliases); i++ {
		if swag.IsZero(m.HostAliases[i]) { // not required
			continue
		}

		if m.HostAliases[i] != nil {
			if err := m.HostAliases[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateInitContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.InitContainers) { // not required
		return nil
	}

	for i := 0; i < len(m.InitContainers); i++ {
		if swag.IsZero(m.InitContainers[i]) { // not required
			continue
		}

		if m.InitContainers[i] != nil {
			if err := m.InitContainers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateInputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Inputs) { // not required
		return nil
	}

	if m.Inputs != nil {
		if err := m.Inputs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateMemoize(formats strfmt.Registry) error {
	if swag.IsZero(m.Memoize) { // not required
		return nil
	}

	if m.Memoize != nil {
		if err := m.Memoize.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoize")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {
		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateMetrics(formats strfmt.Registry) error {
	if swag.IsZero(m.Metrics) { // not required
		return nil
	}

	if m.Metrics != nil {
		if err := m.Metrics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrics")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateOutputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Outputs) { // not required
		return nil
	}

	if m.Outputs != nil {
		if err := m.Outputs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateResource(formats strfmt.Registry) error {
	if swag.IsZero(m.Resource) { // not required
		return nil
	}

	if m.Resource != nil {
		if err := m.Resource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resource")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateRetryStrategy(formats strfmt.Registry) error {
	if swag.IsZero(m.RetryStrategy) { // not required
		return nil
	}

	if m.RetryStrategy != nil {
		if err := m.RetryStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryStrategy")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateScript(formats strfmt.Registry) error {
	if swag.IsZero(m.Script) { // not required
		return nil
	}

	if m.Script != nil {
		if err := m.Script.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("script")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateSecurityContext(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityContext) { // not required
		return nil
	}

	if m.SecurityContext != nil {
		if err := m.SecurityContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityContext")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateSidecars(formats strfmt.Registry) error {
	if swag.IsZero(m.Sidecars) { // not required
		return nil
	}

	for i := 0; i < len(m.Sidecars); i++ {
		if swag.IsZero(m.Sidecars[i]) { // not required
			continue
		}

		if m.Sidecars[i] != nil {
			if err := m.Sidecars[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sidecars" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateSteps(formats strfmt.Registry) error {
	if swag.IsZero(m.Steps) { // not required
		return nil
	}

	for i := 0; i < len(m.Steps); i++ {

		if err := m.Steps[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("steps" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateSuspend(formats strfmt.Registry) error {
	if swag.IsZero(m.Suspend) { // not required
		return nil
	}

	if m.Suspend != nil {
		if err := m.Suspend.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("suspend")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateSynchronization(formats strfmt.Registry) error {
	if swag.IsZero(m.Synchronization) { // not required
		return nil
	}

	if m.Synchronization != nil {
		if err := m.Synchronization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synchronization")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateTemplateRef(formats strfmt.Registry) error {
	if swag.IsZero(m.TemplateRef) { // not required
		return nil
	}

	if m.TemplateRef != nil {
		if err := m.TemplateRef.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("templateRef")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateTolerations(formats strfmt.Registry) error {
	if swag.IsZero(m.Tolerations) { // not required
		return nil
	}

	for i := 0; i < len(m.Tolerations); i++ {
		if swag.IsZero(m.Tolerations[i]) { // not required
			continue
		}

		if m.Tolerations[i] != nil {
			if err := m.Tolerations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tolerations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) validateVolumes(formats strfmt.Registry) error {
	if swag.IsZero(m.Volumes) { // not required
		return nil
	}

	for i := 0; i < len(m.Volumes); i++ {
		if swag.IsZero(m.Volumes[i]) { // not required
			continue
		}

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this io argoproj workflow v1alpha1 template based on the context it is used
func (m *IoArgoprojWorkflowV1alpha1Template) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActiveDeadlineSeconds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAffinity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArchiveLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateArguments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContainer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDag(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExecutor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostAliases(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInitContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemoize(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetrics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetryStrategy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateScript(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSecurityContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSidecars(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSuspend(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSynchronization(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTemplateRef(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTolerations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateActiveDeadlineSeconds(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ActiveDeadlineSeconds.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("activeDeadlineSeconds")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateAffinity(ctx context.Context, formats strfmt.Registry) error {

	if m.Affinity != nil {
		if err := m.Affinity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("affinity")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateArchiveLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.ArchiveLocation != nil {
		if err := m.ArchiveLocation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("archiveLocation")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateArguments(ctx context.Context, formats strfmt.Registry) error {

	if m.Arguments != nil {
		if err := m.Arguments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("arguments")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateContainer(ctx context.Context, formats strfmt.Registry) error {

	if m.Container != nil {
		if err := m.Container.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("container")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateDag(ctx context.Context, formats strfmt.Registry) error {

	if m.Dag != nil {
		if err := m.Dag.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dag")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateExecutor(ctx context.Context, formats strfmt.Registry) error {

	if m.Executor != nil {
		if err := m.Executor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("executor")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateHostAliases(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HostAliases); i++ {

		if m.HostAliases[i] != nil {
			if err := m.HostAliases[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostAliases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateInitContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.InitContainers); i++ {

		if m.InitContainers[i] != nil {
			if err := m.InitContainers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("initContainers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateInputs(ctx context.Context, formats strfmt.Registry) error {

	if m.Inputs != nil {
		if err := m.Inputs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateMemoize(ctx context.Context, formats strfmt.Registry) error {

	if m.Memoize != nil {
		if err := m.Memoize.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoize")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata != nil {
		if err := m.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateMetrics(ctx context.Context, formats strfmt.Registry) error {

	if m.Metrics != nil {
		if err := m.Metrics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrics")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateOutputs(ctx context.Context, formats strfmt.Registry) error {

	if m.Outputs != nil {
		if err := m.Outputs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateResource(ctx context.Context, formats strfmt.Registry) error {

	if m.Resource != nil {
		if err := m.Resource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resource")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateRetryStrategy(ctx context.Context, formats strfmt.Registry) error {

	if m.RetryStrategy != nil {
		if err := m.RetryStrategy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryStrategy")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateScript(ctx context.Context, formats strfmt.Registry) error {

	if m.Script != nil {
		if err := m.Script.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("script")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateSecurityContext(ctx context.Context, formats strfmt.Registry) error {

	if m.SecurityContext != nil {
		if err := m.SecurityContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityContext")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateSidecars(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Sidecars); i++ {

		if m.Sidecars[i] != nil {
			if err := m.Sidecars[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sidecars" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("steps" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateSuspend(ctx context.Context, formats strfmt.Registry) error {

	if m.Suspend != nil {
		if err := m.Suspend.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("suspend")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateSynchronization(ctx context.Context, formats strfmt.Registry) error {

	if m.Synchronization != nil {
		if err := m.Synchronization.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synchronization")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateTemplateRef(ctx context.Context, formats strfmt.Registry) error {

	if m.TemplateRef != nil {
		if err := m.TemplateRef.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("templateRef")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateTolerations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tolerations); i++ {

		if m.Tolerations[i] != nil {
			if err := m.Tolerations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tolerations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1Template) contextValidateVolumes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Volumes); i++ {

		if m.Volumes[i] != nil {
			if err := m.Volumes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *IoArgoprojWorkflowV1alpha1Template) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IoArgoprojWorkflowV1alpha1Template) UnmarshalBinary(b []byte) error {
	var res IoArgoprojWorkflowV1alpha1Template
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
