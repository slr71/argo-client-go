// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IoArgoprojWorkflowV1alpha1NodeStatus NodeStatus contains status information about an individual node in the workflow
//
// swagger:model io.argoproj.workflow.v1alpha1.NodeStatus
type IoArgoprojWorkflowV1alpha1NodeStatus struct {

	// BoundaryID indicates the node ID of the associated template root node in which this node belongs to
	BoundaryID string `json:"boundaryID,omitempty"`

	// Children is a list of child node IDs
	Children []string `json:"children"`

	// Daemoned tracks whether or not this node was daemoned and need to be terminated
	Daemoned bool `json:"daemoned,omitempty"`

	// DisplayName is a human readable representation of the node. Unique within a template boundary
	DisplayName string `json:"displayName,omitempty"`

	// Time at which this node completed
	// Format: date-time
	FinishedAt IoK8sApimachineryPkgApisMetaV1Time `json:"finishedAt,omitempty"`

	// HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
	HostNodeName string `json:"hostNodeName,omitempty"`

	// ID is a unique identifier of a node within the worklow It is implemented as a hash of the node name, which makes the ID deterministic
	// Required: true
	ID *string `json:"id"`

	// Inputs captures input parameter values and artifact locations supplied to this template invocation
	Inputs *IoArgoprojWorkflowV1alpha1Inputs `json:"inputs,omitempty"`

	// MemoizationStatus holds information about cached nodes
	MemoizationStatus *IoArgoprojWorkflowV1alpha1MemoizationStatus `json:"memoizationStatus,omitempty"`

	// A human readable message indicating details about why the node is in this condition.
	Message string `json:"message,omitempty"`

	// Name is unique name in the node tree used to generate the node ID
	// Required: true
	Name *string `json:"name"`

	// OutboundNodes tracks the node IDs which are considered "outbound" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as "outbound". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.
	//
	// In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the "outbound" node. In the case of DAGs, outbound nodes are the "target" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children.
	OutboundNodes []string `json:"outboundNodes"`

	// Outputs captures output parameter values and artifact locations produced by this template invocation
	Outputs *IoArgoprojWorkflowV1alpha1Outputs `json:"outputs,omitempty"`

	// Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine.
	Phase string `json:"phase,omitempty"`

	// PodIP captures the IP of the pod for daemoned steps
	PodIP string `json:"podIP,omitempty"`

	// ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
	ResourcesDuration map[string]int64 `json:"resourcesDuration,omitempty"`

	// Time at which this node started
	// Format: date-time
	StartedAt IoK8sApimachineryPkgApisMetaV1Time `json:"startedAt,omitempty"`

	// StoredTemplateID is the ID of stored template. DEPRECATED: This value is not used anymore.
	StoredTemplateID string `json:"storedTemplateID,omitempty"`

	// SynchronizationStatus is the synchronization status of the node
	SynchronizationStatus *IoArgoprojWorkflowV1alpha1NodeSynchronizationStatus `json:"synchronizationStatus,omitempty"`

	// TemplateName is the template name which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)
	TemplateName string `json:"templateName,omitempty"`

	// TemplateRef is the reference to the template resource which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)
	TemplateRef *IoArgoprojWorkflowV1alpha1TemplateRef `json:"templateRef,omitempty"`

	// TemplateScope is the template scope in which the template of this node was retrieved.
	TemplateScope string `json:"templateScope,omitempty"`

	// Type indicates type of node
	// Required: true
	Type *string `json:"type"`

	// WorkflowTemplateName is the WorkflowTemplate resource name on which the resolved template of this node is retrieved. DEPRECATED: This value is not used anymore.
	WorkflowTemplateName string `json:"workflowTemplateName,omitempty"`
}

// Validate validates this io argoproj workflow v1alpha1 node status
func (m *IoArgoprojWorkflowV1alpha1NodeStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFinishedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoizationStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSynchronizationStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplateRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateFinishedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.FinishedAt) { // not required
		return nil
	}

	if err := m.FinishedAt.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("finishedAt")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateInputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Inputs) { // not required
		return nil
	}

	if m.Inputs != nil {
		if err := m.Inputs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateMemoizationStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.MemoizationStatus) { // not required
		return nil
	}

	if m.MemoizationStatus != nil {
		if err := m.MemoizationStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoizationStatus")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateOutputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Outputs) { // not required
		return nil
	}

	if m.Outputs != nil {
		if err := m.Outputs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateStartedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.StartedAt) { // not required
		return nil
	}

	if err := m.StartedAt.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("startedAt")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateSynchronizationStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.SynchronizationStatus) { // not required
		return nil
	}

	if m.SynchronizationStatus != nil {
		if err := m.SynchronizationStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synchronizationStatus")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateTemplateRef(formats strfmt.Registry) error {
	if swag.IsZero(m.TemplateRef) { // not required
		return nil
	}

	if m.TemplateRef != nil {
		if err := m.TemplateRef.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("templateRef")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this io argoproj workflow v1alpha1 node status based on the context it is used
func (m *IoArgoprojWorkflowV1alpha1NodeStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFinishedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemoizationStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStartedAt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSynchronizationStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTemplateRef(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateFinishedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := m.FinishedAt.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("finishedAt")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateInputs(ctx context.Context, formats strfmt.Registry) error {

	if m.Inputs != nil {
		if err := m.Inputs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateMemoizationStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.MemoizationStatus != nil {
		if err := m.MemoizationStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoizationStatus")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateOutputs(ctx context.Context, formats strfmt.Registry) error {

	if m.Outputs != nil {
		if err := m.Outputs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outputs")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateStartedAt(ctx context.Context, formats strfmt.Registry) error {

	if err := m.StartedAt.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("startedAt")
		}
		return err
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateSynchronizationStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.SynchronizationStatus != nil {
		if err := m.SynchronizationStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("synchronizationStatus")
			}
			return err
		}
	}

	return nil
}

func (m *IoArgoprojWorkflowV1alpha1NodeStatus) contextValidateTemplateRef(ctx context.Context, formats strfmt.Registry) error {

	if m.TemplateRef != nil {
		if err := m.TemplateRef.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("templateRef")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *IoArgoprojWorkflowV1alpha1NodeStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IoArgoprojWorkflowV1alpha1NodeStatus) UnmarshalBinary(b []byte) error {
	var res IoArgoprojWorkflowV1alpha1NodeStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
